# Shadow Masks
```
Bake static shadows.

Combine realtime lighting with baked shadows.

Mix realtime and baked shadows.

Support up to four shadow mask lights.

```
```
使用lightmap的好处在于不受最大阴影距离的限制。（全局且静态的）

使用shadow mask则在阴影距离下使用实时阴影，超过时使用baked lightmap
```
## detecting shadow mask
```
static string[] shadowMaskKeywords = {
		"_SHADOW_MASK_DISTANCE"
	};

bool useShadowMask;
跟踪是否在使用shadowmask

在ReserveDirectionalShadows中检查光源：
LightBakingOutput lightBaking = light.bakingOutput;
	if (
		lightBaking.lightmapBakeType == LightmapBakeType.Mixed &&
		lightBaking.mixedLightingMode == MixedLightingMode.Shadowmask
	) {
		useShadowMask = true;
	}

Shadows.hlsl:

struct ShadowMask {
	bool distance;
	float4 shadows;
};
......


GI.hlsl:

	TEXTURE2D(unity_ShadowMask);
	SAMPLER(samplerunity_ShadowMask);

	gi.shadowMask.distance = false;
	gi.shadowMask.shadows = 1.0;

	float4 SampleBakedShadows (float2 lightMapUV) {
		#if defined(LIGHTMAP_ON)
			return SAMPLE_TEXTURE2D(
				unity_ShadowMask, samplerunity_ShadowMask, lightMapUV
			);
		#else
			return 1.0;
		#endif
	}

	#if defined(_SHADOW_MASK_DISTANCE)
		gi.shadowMask.distance = true;
		gi.shadowMask.shadows = SampleBakedShadows(lightMapUV);
	#endif
......


Lighting.hlsl:

	shadowData.shadowMask = gi.shadowMask;
	return gi.shadowMask.shadows.rgb;
......

CameraRenderer.cs:

	perObjectData =
		PerObjectData.Lightmaps | PerObjectData.ShadowMask |
		PerObjectData.LightProbe |
		PerObjectData.LightProbeProxyVolume
```
## Occlution Probes
```
UnityInput.hlsl:
	real4 unity_WorldTransformParams;

	float4 unity_ProbesOcclusion;

	float4 unity_LightmapST;
......	
GI.hlsl:
	float4 SampleBakedShadows (float2 lightMapUV) {
		#if defined(LIGHTMAP_ON)
		…
		#else
			return unity_ProbesOcclusion;
		#endif
	}
......			
CameraRenderer.cs:
	perObjectData =
		PerObjectData.Lightmaps | PerObjectData.ShadowMask |
		PerObjectData.LightProbe | PerObjectData.OcclusionProbe |
		PerObjectData.LightProbeProxyVolume

probes 的 shadow masks 会影响 gpu instanced，在common中额外定义，在引入UnityInstancing.hlsl前：
	#if defined(_SHADOW_MASK_DISTANCE)
	#define SHADOWS_SHADOWMASK
#endif

	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"

```
## LPPVs
```
CameraRenderer.cs:
	perObjectData =
				PerObjectData.Lightmaps | PerObjectData.ShadowMask |
				PerObjectData.LightProbe | PerObjectData.OcclusionProbe |
				PerObjectData.LightProbeProxyVolume |
				PerObjectData.OcclusionProbeProxyVolume
......
GI.hlsl:
float4 SampleBakedShadows (float2 lightMapUV, Surface surfaceWS) {
	#if defined(LIGHTMAP_ON)
		…
	#else
		if (unity_ProbeVolumeParams.x) {
			return SampleProbeOcclusion(
				TEXTURE3D_ARGS(unity_ProbeVolumeSH, samplerunity_ProbeVolumeSH),
				surfaceWS.position, unity_ProbeVolumeWorldToObject,
				unity_ProbeVolumeParams.y, unity_ProbeVolumeParams.z,
				unity_ProbeVolumeMin.xyz, unity_ProbeVolumeSizeInv.xyz
			);
		}
		else {
			return unity_ProbesOcclusion;
		}
	#endif
}

gi.shadowMask.shadows = SampleBakedShadows(lightMapUV, surfaceWS);
......
```
## Mixing Shadows
```
Shadows.hlsl:

float GetCascadedShadow (
	DirectionalShadowData directional, ShadowData global, Surface surfaceWS
) {
	float3 normalBias = surfaceWS.normal *
		(directional.normalBias * _CascadeData[global.cascadeIndex].y);
	float3 positionSTS = mul(
		_DirectionalShadowMatrices[directional.tileIndex],
		float4(surfaceWS.position + normalBias, 1.0)
	).xyz;
	float shadow = FilterDirectionalShadow(positionSTS);
	if (global.cascadeBlend < 1.0) {
		normalBias = surfaceWS.normal *
			(directional.normalBias * _CascadeData[global.cascadeIndex + 1].y);
		positionSTS = mul(
			_DirectionalShadowMatrices[directional.tileIndex + 1],
			float4(surfaceWS.position + normalBias, 1.0)
		).xyz;
		shadow = lerp(
			FilterDirectionalShadow(positionSTS), shadow, global.cascadeBlend
		);
	}
	return shadow;
}

将GetDirectionalShadowAttenuation的后续部分转至GetCascadedShadow中

float GetDirectionalShadowAttenuation (
	DirectionalShadowData directional, ShadowData global, Surface surfaceWS
) {
	#if !defined(_RECEIVE_SHADOWS)
		return 1.0;
	#endif
	
	float shadow;
	if (directional.strength <= 0.0) {
		shadow = 1.0;
	}
	else {
		shadow = GetCascadedShadow(directional, global, surfaceWS);
		shadow = lerp(1.0, shadow, directional.strength);
	}
	return shadow;
}

float GetBakedShadow (ShadowMask mask) {
	float shadow = 1.0;
	if (mask.distance) {
		shadow = mask.shadows.r;
	}
	return shadow;
}

float MixBakedAndRealtimeShadows (
	ShadowData global, float shadow, float strength
) {
	float baked = GetBakedShadow(global.shadowMask);
	if (global.shadowMask.distance) {
		shadow = baked;
	}
	return lerp(1.0, shadow, strength);
}
根据是否启用shadow mask来决定是否使用baked shadow
```
